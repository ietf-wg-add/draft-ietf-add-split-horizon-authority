<?xml version='1.0' encoding='utf-8'?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<?xml-model href="https://raw.githubusercontent.com/ietf-tools/xml2rfc/main/xml2rfc/data/v3.rng" schematypens="http://relaxng.org/ns/structure/1.0" type="application/xml"?>
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-ietf-add-split-horizon-authority-latest" ipr="trust200902" submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3" consensus="true">
  <front>
    <title abbrev="Establishing Local DNS Authority">Establishing Local DNS
    Authority in Validated Split-Horizon Environments</title>
    <seriesInfo name="Internet-Draft" value="draft-ietf-add-split-horizon-authority-latest"/>
    <author fullname="Tirumaleswar Reddy" initials="T." surname="Reddy">
      <organization>Nokia</organization>
      <address>
        <postal>
          <country>India</country>
        </postal>
        <email>kondtir@gmail.com</email>
      </address>
    </author>
    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Citrix">Citrix Systems, Inc.</organization>
      <address>
        <postal>
          <street>4988 Great America Pkwy</street>
          <city>Santa Clara</city>
          <region>CA</region>
          <code>95054</code>
          <country>USA</country>
        </postal>
        <email>danwing@gmail.com</email>
      </address>
    </author>
    <author fullname="Kevin Smith" initials="K." surname="Smith">
      <organization abbrev="Vodafone">Vodafone Group</organization>
      <address>
        <postal>
          <street>One Kingdom Street</street>
          <city>London</city>
          <country>UK</country>
        </postal>
        <email>kevin.smith@vodafone.com</email>
      </address>
    </author>
    <author fullname="Benjamin Schwartz" initials="B." surname="Schwartz">
      <organization abbrev="Meta">Meta Platforms, Inc.</organization>
      <address>
        <email>ietf@bemasc.net</email>
      </address>
    </author>
    <date/>
    <workgroup>ADD</workgroup>
    <abstract>
      <t>When split-horizon DNS is deployed by a network, certain domains can
      be resolved authoritatively by the network-provided DNS resolver. DNS
      clients that don't always use this resolver might wish to do so for
      these domains. This specification defines a mechanism for domain owners
      to inform clients about local resolvers that are authorized to answer
      authoritatively for certain subdomains.</t>
    </abstract>
    <note title="Discussion Venues" removeInRFC="true">
      <t>Discussion of this document takes place on the
          Adaptive DNS Discovery Working Group mailing list (add@ietf.org),
          which is archived at <eref target="https://mailarchive.ietf.org/arch/browse/add/"/>.</t>
      <t>Source for this draft and an issue tracker can be found at
          <eref target="https://github.com/ietf-wg-add/draft-ietf-add-split-horizon-authority"/>.</t>
      </note>
    </front>
  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>To resolve a DNS query, there are three essential behaviors that an
      implementation can apply: (1) answer from a local database, (2) query
      the relevant authorities and their parents, or (3) ask a server to query
      those authorities and return the final answer. Implementations that use
      these behaviors are called "authoritative nameservers", "full/recursive
      resolvers", and "forwarders" (or "stub resolvers") respectively. However, an
      implementation can also implement a mixture of these behaviors,
      depending on a local policy, for each query. We term such an
      implementation a "hybrid resolver".</t>
      <t>Most DNS resolvers are hybrids of some kind. For example, stub
      resolvers frequently support a local "hosts file" that preempts query
      forwarding, and most DNS forwarders and full resolvers can also serve
      responses from a local zone file. Other standardized hybrid resolution
      behaviors include <xref target="RFC8806">Local Root</xref>, <xref
      target="RFC6762">mDNS</xref>, and <xref target="RFC7686">NXDOMAIN
      synthesis for .onion</xref>.</t>
      <t>In many network environments, the network offers clients a DNS server
      (e.g. DHCP OFFER, IPv6 Router Advertisement). Although this server is
      formally specified as a recursive resolver (e.g. <relref section="5.1"
      target="RFC8106"/>), some networks provide a hybrid resolver
      instead. If this resolver acts as an authoritative server for some
      names, we say that the network has "split-horizon DNS", because those
      names resolve in this way only from inside the network.</t>
      <t>Network clients that use pure stub resolution, sending all queries to
      the network-provided resolver, will always receive the split-horizon
      results. Conversely, clients that send all queries to a different
      resolver or implement pure full resolution locally will never receive
      them. Clients that strictly implement either of these resolution behaviors are out of scope for
      this specification. Instead, this specification enables hybrid clients
      to access split-horizon results from a network-provided hybrid resolver,
      while using a different resolution method for some or all other
      names.</t>
      <t>There are several existing mechanisms for a network to provide
      clients with "local domain hints", listing domain names that have
      special treatment in this network (e.g., <xref target="RFC6731">
      RDNSS Selection</xref>, <xref target="RFC5986">
      "Access Network Domain Name"</xref>, and "Client FQDN" <xref
      target="RFC4702"/><xref target="RFC4704"/> in DHCP, "dnsZones" in
      Provisioning Domains <xref target="RFC8801"/>, and <xref
      target="RFC8598">INTERNAL_DNS_DOMAIN</xref> in IKEv2).
      However, none of the local domain hint mechanisms enable clients to
      determine whether this special treatment is authorized by the domain
      owner. Instead, these specifications require clients to make their own
      determinations about whether to trust and rely on these hints.</t>
      <t>This specification describes a protocol between domains, networks,
      and clients that allows the network to establish its authority over a
      domain to a client (<xref target="establishing"/>). Clients can
      use this protocol to confirm that a local domain hint was authorized by
      the domain (<xref target="validating"/>), which might influence
      its processing of that hint.  This process requires cooperation between
      the local DNS zone and the public zone.</t>
      <t>This specification relies on securely identified local DNS servers,
      and checks each local domain hint against a globally valid parent zone.</t>
    </section>
    <section anchor="notation">
      <name>Terminology</name>
      <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
      "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and
      "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"/><xref target="RFC8174"/> when, and
      only when, they appear in all capitals, as shown here.</t>
      <t>This document makes use of the terms defined in <xref
      target="RFC8499"/>, e.g. "Global DNS".  The following additional terms are
      used throughout the document:</t>
      <dl>
        <dt>Encrypted DNS</dt><dd>A DNS protocol that provides an
        encrypted channel between a DNS client and server (e.g., DNS
        over TLS (DoT), HTTPS (DoH), QUIC (DoQ)).</dd>
          <dt>Split-Horizon DNS</dt><dd>The DNS service provided by a resolver
          that also acts as an authoritative server for some names, providing
          resolution results that are meaningfully different from those in the
          Global DNS. (See "Split DNS" in <relref section="6"
          target="RFC8499"/>.)</dd>
        <dt>Validated Split-Horizon</dt><dd>A split horizon configuration for
          some name is considered "validated" if the client has confirmed that
          a parent of that name has authorized this resolver  to serve its own
          responses for that name. Such authorization generally extends to the
          entire subtree of names below the authorization point.</dd>
      </dl>
    </section>
    <section>
      <name>Scope</name>
      <t>The protocol in this document is designed to support the ability of
      a domain owner to create or authorize a split-horizon view of their
      domain. The protocol does not support split-horizon views created by
      any other entity. Thus, DNS filtering is not enabled by this protocol.</t>
      <t>The protocol is applicable to any type of network offering
      split-horizon DNS configuration. The endpoint does not need any prior
      configuration to confirm that a local domain hint was indeed authorized
      by the domain.</t>
      <t>All of the special-use domain names registered with IANA <xref target="IANA-SUDN"/>,
      most notably ".home.arpa", "resolver.arpa.", "ipv4only.arpa." and ".local", are never
      unique to a specific DNS server's authority. All special-use domain names are outside the
      scope of this document and MUST NOT be validated using the mechanism described in this document. </t>
      <t> Use of this specification is limited to DNS servers that support authenticated encryption and
      split-horizon DNS names that are rooted in the global DNS.</t>
    </section>
    <section>
      <name>Requirements</name>
      <t>This solution seeks to fulfill the following requirements:</t>
      <ul>
        <li>No loss of security: No unauthorized party can impersonate
          a zone unless they could already do so without use of this
          specification.</li>
        <li>Least privilege: Local resolvers do not hold any
          secrets that could weaken the security of the public zone if
          compromised.</li>
        <li>Local zone confidentiality: The specification does not leak
          local network subdomains to anyone outside of the network.</li>
        <li>Flexibility: The specification can represent and authorize
          a typical Split DNS zone structure.</li>
        <li>DNSSEC Compatibility: The specification supports DNSSEC-based
          object security for local zone contents.</li>
      </ul>
    </section>
    <section anchor="establishing">
      <name>Establishing Local DNS Authority</name>
      <t>To establish its authority over some DNS zone, a
      participating network <bcp14>MUST</bcp14> offer one or more
      encrypted resolvers via DNR <xref target="I-D.ietf-add-dnr"/>,
      DDR <xref target="I-D.ietf-add-ddr"/>, or an equivalent mechanism
      (see <xref target="vpn"/>).</t>
      <t>To establish local authority, the network MUST convey one or more
      "Authorization Claims" to the client.  An "Authorization Claim" is an
      abstract structure comprising:</t>
      <ul>
        <li>An Authentication Domain Name (ADN) of a local encrypted resolver.</li>
        <li>The DNS name of the authorizing parent zone.</li>
        <li>A set of subdomains of this parent zone that are claimed by
            the named local resolver (potentially including the entire parent
            zone). To claim the entire parent zone, the claimed subdomain
            will be represented as an asterisk symbol "*".</li>
        <li>A ZONEMD Hash Algorithm (<relref section="5.3" target="RFC8976"/>).
           For interoperability purposes implementations MUST support the
           "mandatory to implement" hash algorithms defined in
           <relref section="2.2.3" target="RFC8976"/>. </li>
        <li>A high-entropy salt, up to 255 octets.</li>
      </ul>
      <t>If the local encrypted resolver is identified by name (e.g., DNR), that
      identifying name MUST be the one used in any corresponding Authorization
      Claim.  Otherwise (e.g., DDR using IP addresses), the resolver MUST
      present a validatable certificate containing a subjectAltName that
      matches the Authorization Claim.</t>
      <t>To establish its authority, the network MUST provide each Authorization
      Claim to the parent zone operator.  If the contents are approved, the
      parent zone operator computes a "Verification Token" according to the
      following procedure:</t>
      <ol>
        <li>Convert all subdomains into canonical form and sort them in canonical
            order (<relref section="6" target="RFC4034"/>).</li>
        <li>Replace the suffix corresponding to the parent zone with a zero
            byte.</li>
        <li>Let $X be the concatenation of the resulting pseudo-FQDNs.</li>
        <li>Let len($SALT) be the number of octets of salt, as a single octet.</li>
        <li>Let $TOKEN = hash(len($SALT) || $SALT || $X). Where "||" denotes concatenation.</li>
      </ol>
      <t>The zone operator then publishes a "Verification Record" with the
      following structure, following the advice in Sections 5.1 and 5.2 of
      <xref target="I-D.ietf-dnsop-domain-verification-techniques"/>:</t>
      <ul>
        <li>Type = TXT.</li>
        <li>Owner Name = Concatenation of the ADN, "_splitdns-challenge", and
            the parent zone name.</li>
        <li>Contents = "token=base64url($TOKEN)" (without padding)</li>
      </ul>
      <t>By publishing this record, the parent zone authorizes the local
      encrypted resolver to serve these subdomains authoritatively.</t>
      <section>
        <name>Example</name>
        <t>Consider the following authorization claim:</t>
        <ul>
          <li>ADN = "resolver17.parent.example"</li>
          <li>Parent = "parent.example"</li>
          <li>Subdomains = "payroll.parent.example",
              "secret.project.parent.example"</li>
          <li>Hash Algorithm = SHA-384</li>
          <li>Salt = "example salt bytes (should be random)"</li>
        </ul>
        <t>To approve this claim, the zone operator would publish the following record:</t>
        <t>NOTE: '\' line wrapping per <xref target="RFC8792"/></t>
        <sourcecode type="dns-rr">
  resolver17.parent.example._splitdns-challenge.parent.example. \
  IN TXT "token=6rQ7oOZqdg8qQFRqtxpEhK97mNkgFwzNKTmNOtlxspBscZq\
  UwFZZJDDD-Djetw2MCg"
</sourcecode>
      </section>
      <section>
        <name>Conveying Authorization Claims</name>
        <t>
          The Authorization Claim is an abstract structure that must be encoded in
          some concrete syntax in order to convey it from the network to the client.
          This section defines some encodings of the Authorization Claims.
        </t>
        <section>
          <name>Using DHCP</name>
          <t>
            In DHCP, each Authorization Claim is encoded as a DHCP Authentication
            Option (<xref target="RFC3118"/> and <relref section="21.11" target="RFC8415"/>),
            using the Protocol value $TBD1, "Split DNS Authentication". In DHCPv4, the long-options
            mechanism described in <relref section="8" target="RFC3396"/> MUST be used if the
            authentication option exceeds the maximum DHCPv4 option size of 255 octets. The Algorithm field
            provides the ZONEMD Hash Algorithm, represented by its registered Value.
            The Replay Detection Method (RDM) value <bcp14>MUST</bcp14> be 0x00. The Authentication Information
            <bcp14>MUST</bcp14> contain the following information, concatenated:</t>
          <ol>
            <li>The ADN in canonical form.</li>
            <li>The parent name in canonical form.</li>
            <li>A one-octet "salt length" field.</li>
            <li>The salt value.</li>
            <li>The $X value defined in <xref target="establishing"/>.</li>
          </ol>
        </section>
        <section>
          <name>Using Provisioning Domains</name>
          <t>When using <xref target="RFC8801">Provisioning Domains</xref>, the
          Authorization Claims are represented by the PvD Additional
          Information key "splitDnsClaims", whose value is a
          JSON Array.  Each entry in the array <bcp14>MUST</bcp14> be a JSON object
          with the following structure:</t>
          <ul>
            <li>"resolver": The ADN as a dot-separated name.</li>
            <li>"parent": The parent zone name as a dot-separated name.</li>
            <li>"subdomains": An array containing the claimed subdomains, as
                dot-separated names with the parent suffix already removed, in
                canonical order. To claim the entire parent zone, the claimed subdomain 
                will be represented as an asterisk symbol "*".</li>
            <li>"algorithm": The hash algorithm is represented by its "Mnemonic"
                string from the ZONEMD Hash Algorithms registry (<relref target="RFC8976"
                section="5.2" displayFormat="comma"/>).</li>
            <li>"salt": The salt, encoded in base64url.</li>
          </ul>
        </section>
      </section>
    </section>
    <section anchor="validating">
      <name>Validating Authority over Local Domain Hints</name>
      <t>To validate an Authorization Claim provided by the network, participating
      clients <bcp14>MUST</bcp14> resolve the Verification Record for that name.
      If the resolution produces an RRSet containing the expected token for this
      Claim, the client <bcp14>SHALL</bcp14> regard the named resolver as
      authoritative for the claimed subdomains. Clients <bcp14>MUST</bcp14> ignore
      any unrecognized keys in the Verification Record.</t>
      <t>Each validation of authority applies only to a specific Authentication
      Domain Name. If a network offers multiple encrypted resolvers, each claimed
      subdomain may be authorized for a distinct subset of the network-provided
      resolvers.</t>
      <t>A zone is termed a "Validated Split-Horizon zone" after successful
      validation using a "tamperproof" DNS resolution method, i.e. a method
      that is not subject to interference by the local network operator. Two
      possible tamperproof resolution methods are presented below.</t>
      <section anchor="validating-external">
        <name>Using a Pre-configured External Resolver</name>
        <t>This method applies only if the client is already configured with
        a default resolution strategy that sends queries to a resolver outside
        of the network over a encrypted transport.  That resolution strategy is
        considered "tamperproof" because any actor who could modify the
        response could already modify all of the user's other DNS responses.</t>
        <t>To ensure that this assumption holds, clients <bcp14>MUST NOT</bcp14>
        relax the acceptance rules they would otherwise apply when using this
        resolver. For example, if the client would check the AD bit or
        validate RRSIGs locally when using this resolver, it must also do so
        when resolving TXT records for this purpose. Alternatively, a client might
        perform DNSSEC validation for the verification query
        even if it has disabled DNSSEC validation for other DNS queries.</t>
      </section>
      <!-- validating-external -->

      <section anchor="validating-dnssec">
        <name>Using DNSSEC</name>
        <t>The client resolves the Verification Record using any resolution method of
        its choice (e.g. querying one of the network-provided resolvers,
        performing iterative resolution locally), and performs full DNSSEC
        validation locally <xref target="RFC6698"/>. The result is
        processed based on its DNSSEC validation state (<relref section="4.3"
        target="RFC4035" displayFormat="comma"/>): </t>
        <ul empty="true">
          <li><strong>Secure</strong>: The response is used for validation.</li>
          <li><strong>Bogus</strong> or <strong>Indeterminate</strong>: The response is rejected and
            validation is considered to have failed.</li>
          <li><strong>Insecure</strong>: The client <bcp14>SHOULD</bcp14> retry the validation
            process using a different method, such as the one in <xref
            target="validating-external"/>, to ensure compatibility with
            unsigned names.</li>
        </ul>
      </section>
      <!-- validating-DNSSEC -->
    </section>
    <!-- Validating -->

    <section>
      <name>Delegating DNSSEC across Split DNS Boundaries</name>
      <t>We wish to enable DNSSEC validation of local DNS names without requiring
      the local resolver to hold DNSSEC private keys that are valid for the parent
      zone.  To support this configuration, parent zones <bcp14>MAY</bcp14> add a
      "ds=..." key to the Verification Record whose value is the RDATA of a single
      DS record, base64url-encoded. This DS record authorizes a DNSKEY whose Owner
      Name is "resolver.arpa."</t>
      <t>To validate DNSSEC, the client first fetches and validates the Verification
      Record.  If it is valid and contains a "ds" key, the client <bcp14>MAY</bcp14>
      send a DNSKEY query for "resolver.arpa." to the local encrypted resolver.
      At least one resulting DNSKEY RR <bcp14>MUST</bcp14> match the DS RDATA from
      the "ds" key in the Verification Record. All local resolution results for
      subdomains in this claim <bcp14>MUST</bcp14> offer RRSIGs that chain to one
      of these approved DNSKEYs.</t>
      <t>The "ds" key <bcp14>MAY</bcp14> appear multiple
      times in a single Verification Record, in order to authorize multiple DNSKEYs
      for this local encrypted resolver.  If the "ds" key is not present in a valid
      Verification Record, the client <bcp14>MUST</bcp14> disable DNSSEC validation
      when resolving the claimed subdomains via this local encrypted resolver.</t>
      <figure>
        <name>Example use of "ds=..."</name>
        <sourcecode>
;; Parent zone
$ORIGIN parent.example.

; Parent zone's public KSK and ZSK
@ IN DNSKEY 257 3 5 ABCD...=
@ IN DNSKEY 256 3 5 DCBA...=

; Verification Record containing DS RDATA for the local
; resolver's KSK.  This is an ordinary public TXT record,
; secured by RRSIGs from the public ZSK.
resolver.example._splitdns-challenge IN TXT "token=abc...,ds=QWE..."

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Local zone, claiming "subdomain.parent.example".

; The local resolver's KSK, validated by the Verification Record.
resolver.arpa. IN DNSKEY 257 3 5 ASDF...=

; Each claimed subdomain has its own ZSK, which is signed by the
; KSK and is used to sign records at that subdomain and below.
subdomain.parent.example.        IN DNSKEY 256 3 5 FDSA...=
subdomain.parent.example.        IN AAAA 2001:db8::17
deeper.subdomain.parent.example. IN AAAA 2001:db8::18
</sourcecode></figure>
    </section>

    <section>
      <name>Examples of Split-Horizon DNS Configuration</name>
      <t>Two examples are shown below. The first example shows a company
      with an internal-only DNS server that claims the entire zone for that
      company (e.g., <tt>*.example.com</tt>). In the second example, the
      internal servers resolves only a
      subdomain of the company's zone (e.g., <tt>*.internal.example.com</tt>).</t>
      <section anchor="internal-only">
        <name>Split-Horizon Entire Zone</name>
        <t>Consider an organization that operates "example.com", and runs a
        different version of its global domain on its internal network.</t>
        <t>First, the host and network both need to support one of the discovery
        mechanisms described in <xref target="establishing"/>. <xref target="fig-learn"/>
        shows discovery using DNR and PvD.</t>
        <t>Validation is then perfomed using either <xref
        target="example-verify-external">an external resolver</xref> or <xref
        target="example-verify-dnssec">DNSSEC</xref>.</t>
        <ul empty="true">
          <li><strong>Steps 1-2</strong>: The client determines the network's DNS
            server (dns.example.net) and Provisioning Domain (pvd.example.com)
            using <xref target="I-D.ietf-add-dnr">DNR</xref> and <xref
            target="RFC8801">PvD</xref>, using one of DNR Router Solicitation,
            DHCPv4, or DHCPv6.</li>
          <li><strong>Step 3-5</strong>: The client connects to dns.example.net
            using an encrypted transport as indicated in <xref
            target="I-D.ietf-add-dnr">DNR</xref>, authenticating the server to
            its name using TLS (<relref target="RFC8310" section="8"
            displayFormat="comma"/>), and
            sends it a query for the address of <tt>pvd.example.com</tt>.</li>
          <li><t><strong>Steps 6-7</strong>: The client connects to the PvD server,
            validates its certificate, and retrieves the provisioning domain
            JSON information indicated by the associated PvD. The PvD
            contains:</t>
            <sourcecode type="json">{
  "identifier": "pvd.example.com",
  "expires": "2025-05-23T06:00:00Z",
  "prefixes": ["2001:db8:1::/48", "2001:db8:4::/48"],
  "splitDnsClaims": [{
    "resolver": "dns.example.net",
    "parent": "example.com",
    "subdomains": ["*"],
    "algorithm": "SHA384",
    "salt": "abc...123"
  }]
}</sourcecode>
            <t>The JSON keys "identifier", "expires", and "prefixes"
            are defined in <xref target="RFC8801"/>.</t></li>
        </ul>
        <figure anchor="fig-learn">
          <name>Learning Local Claims of DNS Authority</name>
          <artwork><![CDATA[
+---------+         +--------------------+  +------------+ +--------+
| Client  |         | Network's          |  | Network    | | Router |
|         |         | Encrypted Resolver |  | PvD Server | |        |
+---------+         +--------------------+  +------------+ +--------+
   |                                     |         |            |
   | Router Solicitation or              |         |            |
   | DHCPv4/DHCPv6 (1)                   |         |            |
   |----------------------------------------------------------->|
   |                                     |         |            |
   |  Response with DNR hostnames &      |         |            |
   |  PvD FQDN (2)                       |         |            |
   |<-----------------------------------------------------------|
   | ----------------------------\       |         |            |
   |-| now knows DNR hostnames & |       |         |            |
   | | PvD FQDN                  |       |         |            |
   | |---------------------------/       |         |            |
   |                                     |         |            |
   | TLS connection to dns.example.net (3)         |            |
   |------------------------------------>|         |            |
   | ---------------------------\        |         |            |
   |-| validate TLS certificate |        |         |            |
   | |--------------------------/        |         |            |
   |                                     |         |            |
   | resolve pvd.example.com  (4)        |         |            |
   |------------------------------------>|         |            |
   |                                     |         |            |
   |            A or AAAA records (5)    |         |            |
   |<------------------------------------|         |            |
   |                                     |         |            |
   | https://pvd.example.com/.well-known/pvd (6)   |            |
   |---------------------------------------------->|            |
   |                                     |         |            |
   |  200 OK (JSON Additional Information) (7)     |            |
   |<----------------------------------------------|            |
   | ----------------------------------\ |         |            |
   |-| {..., "splitDnsClaims": [...] } | |         |            |
   | |---------------------------------/ |         |            |
]]></artwork>
        </figure>
        <section anchor="example-verify-external">
          <name>Verification using an external resolver</name>
          <t>The figure below shows the steps performed to verify the local
          claims of DNS authority using an external resolver.</t>
          <ul empty="true">
            <li><strong>Steps 1-2</strong>: The client uses an encrypted DNS
              connection to an external resolver to issue TXT
              queries for the Verification Records. The TXT lookup returns
              a token that matches the claim.</li>
            <li><strong>Step 3</strong>: The client has validated that
              <tt>example.com</tt> has authorized <tt>dns.example.net</tt>
              to serve <tt>example.com</tt>. When the client connects using an
              encrypted transport as indicated in <xref
              target="I-D.ietf-add-dnr">DNR</xref>, it will authenticate
              the server to its name using TLS (<relref target="RFC8310"
              section="8" displayFormat="comma"/>), and send queries to resolve
              any names that fall within the claimed zones.</li>
          </ul>
          <figure>
            <name>Verifying claims using an external resolver</name>
            <artwork><![CDATA[
+---------+                  +--------------------+  +----------+
| Client  |                  | Network's          |  | External |
|         |                  | Encrypted Resolver |  | Resolver |
+---------+                  +--------------------+  +----------+
     |                                          |         |
     | TLS connection                           |         |
     |--------------------------------------------------->|
     | ---------------------------\             |         |
     |-| validate TLS certificate |             |         |
     | |--------------------------|             |         |
     |                                          |         |
     | TXT? dns.example.net.\                   |         |
     |   _splitdns-challenge.example.com  (1)   |         |
     |--------------------------------------------------->|
     |                                          |         |
     |  TXT "token=ABC..."                  (2) |         |
     |<---------------------------------------------------|
     | --------------------------------\        |         |
     |-| dns.example.net is authorized |        |         |
     | ----------------------\---------|        |         |
     |-| finished validation |                  |         |
     | |---------------------|                  |         |
     |                                          |         |
     |  use dns.example.net when                |         |
     |  resolving example.com (3)               |         |
     |----------------------------------------->|         |
     |                                          |         |
]]></artwork>
          </figure>
        </section>
        <!-- external -->

        <section anchor="example-verify-dnssec">
          <name>Verification using DNSSEC</name>
          <t>The figure below shows the steps performed to verify the local
          claims of DNS authority using DNSSEC.</t>
          <ul empty="true">
            <li><strong>Steps 1-2</strong>: The DNSSEC-validating client queries
              the network encrypted resolver to issue TXT queries for the
              Verification Records. The TXT lookup will return
              a signed response containing the expected token. The client then
              performs full DNSSEC validation locally.</li>
            <li><strong>Step 3</strong>: The DNSSEC validation is successful and
              the token matches, so this Authorization Claim is validated.
              When the client connects using an encrypted transport as indicated
              in <xref target="I-D.ietf-add-dnr">DNR</xref>, it will authenticate
              the server to its name using TLS (<relref target="RFC8310"
              section="8" displayFormat="comma"/>), and send queries to resolve
              any names that fall within the claimed zones.</li>
          </ul>
          <figure>
            <name>Verifying claims using DNSSEC</name>
            <artwork><![CDATA[
+---------+                                    +--------------------+
| Client  |                                    | Network's          |
|         |                                    | Encrypted Resolver |
+---------+                                    +--------------------+
  |                                                               |
  | DNSSEC OK (DO), TXT? dns.example.net.\                        |
  |   _splitdns-challenge.example.com  (1)                        |
  |-------------------------------------------------------------->|
  |                                                               |
  | TXT token=DEF..., Signed Answer (RRSIG) (2)                   |
  |<--------------------------------------------------------------|
  | -------------------------------------\                        |
  |-| DNSKEY+TXT matches RRSIG, use TXT  |                        |
  | |------------------------------------|                        |
  | --------------------------------\                             |
  |-| dns.example.net is authorized |                             |
  | |-------------------------------|                             |
  | ----------------------\                                       |
  |-| finished validation |                                       |
  | |---------------------|                                       |
  |                                                               |
  | use encrypted network-designated resolver for example.com (3) |
  |-------------------------------------------------------------->|
  |                                                               |
]]></artwork>
          </figure>
        </section>
      </section>
      <section>
        <name>Internal-only Subdomains</name>
        <t>In many split-horizon deployments, all non-public domain names are
        placed in a separate child zone (e.g., <tt>internal.example.com</tt>).
        In this configuration, the message flow is similar to <xref
        target="internal-only"/>, except that queries for hosts not within the
        subdomain (e.g., <tt>www.example.com</tt>) are sent to the
        external resolver rather than the resolver for internal.example.com.</t>
        <t>As in <xref target="internal-only"/>, the internal DNS
        server will need a certificate signed by a CA trusted by the
        client.</t>
        <t>Although placing internal domains inside a child domain is unnecessary to prevent leakage, 
        such placement reduces the frequency of changes to the Verification Record, this document
        recommends the internal domains be kept in a child zone of the local domain hints
        advertised by the network. For example, if the PvD "dnsZones" entry is 
        “internal.example.com” and the network-provided DNS resolver is “ns1.internal.example.com”,
        the network operator can structure the internal domain names as
        "private1.internal.example.com", "private2.internal.example.com",
        etc. The network-designated resolver will be used to resolve the subdomains of
        the local domain hint “*.internal.example.com”.</t> 
      </section>
    </section>
    <section anchor="vpn">
      <name>Validation with IKEv2</name>
      <t>When the VPN tunnel is IPsec, the encrypted DNS resolver hosted by
      the VPN service provider can be securely discovered by the endpoint
      using the ENCDNS_IP*_* IKEv2 Configuration Payload Attribute Types
      defined in <xref target="I-D.ietf-ipsecme-add-ike"/>. The VPN client
      can use the mechanism defined in Section 6 to validate that the discovered
      encrypted DNS resolver is authorized to answer for the claimed subdomains.</t>
      <t>Other VPN tunnel types have similar configuration capabilities, not
      detailed here.</t>
    </section>
    <section anchor="Security">
      <name>Security Considerations</name>
      <t>The Authentication Domain Names of authorized local encrypted resolvers are
      revealed in the Owner Names of Verification Records.  This makes it easier for
      domain owners to understand which resolvers they are currently authorizing to
      implement Split DNS, but it could create a confidentiality problem if the
      local encrypted resolver's name is inside a secret subdomain. To avoid leakage,
      local resolvers should be given a name that does not reveal any sensitive
      information (perhaps in addition to the more sensitive name).</t>
      <t> The security properties of hashing algorithms are not fixed. Algorithm Agility
      (see <xref target="RFC7696"/>) is achieved by providing implementations with
      flexibility to choose hashing algorithms from the ZONEMD Schemes registry
      (<relref target="RFC8976" section="5.2" displayFormat="comma"/>).</t>
    </section>
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <section>
        <name>DHCP Split DNS Authentication Algorithm</name>
        <t>IANA is requested to add the following entry to the "Protocol Name Space
        Values" registry on the "Dynamic Host Configuration Protocol (DHCP)
        Authentication Option Name Spaces" page:</t>
        <ul>
          <li>Value: $TBD1</li>
          <li>Description: Split DNS</li>
          <li>Reference: (This Document)</li>
        </ul>
      </section>
      <section>
        <name>Provisioning Domains Split DNS Additional Information</name>
        <t>IANA is requested to add the following entry to the "Additional
        Information PvD Keys" registry on the "Provisioning Domains (PvDs)" page:</t>
        <ul>
          <li>JSON key: "splitDnsClaims"</li>
          <li>Description: "Verifiable locally served domains"</li>
          <li>Type: Array of Objects</li>
          <li><t>Example: </t><sourcecode type="json">[{
  "resolver": "dns.example.net",
  "parent": "example.com",
  "subdomains": ["sub"],
  "algorithm": "SHA384",
  "salt": "abc...123"
}]</sourcecode></li>
          <li>Reference: (This document)</li>
        </ul>
      </section>
      <section>
        <name>DNS Underscore Name</name>
        <t>IANA is requested to add the following entry to the "Underscored and
        Globally Scoped DNS Node Names" registry on the "Domain Name System (DNS)
        Parameters" page:</t>
        <ul>
          <li>RR Type: TXT</li>
          <li>_NODE NAME: _splitdns-challenge</li>
          <li>Reference: (This document)</li>
        </ul>
      </section>
    </section>
    <section>
      <name>Acknowledgements</name>
      <t>Thanks to Mohamed Boucadair, Jim Reid, Tommy Pauly, Paul Vixie,
      Michael Richardson, Bernie Volz and Vinny Parla for the discussion and comments.</t>
    </section>
  </middle>
  <!--  *****BACK MATTER ***** -->

  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.3118.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.4034.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8801.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.6762.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.6698.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.4035.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8976.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8415.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.3396.xml"/>
        <reference anchor="IANA-SUDN"
                   target="https://www.iana.org/assignments/special-use-domain-names/special-use-domain-names.xhtml">
          <front>
            <title>Special-Use Domain Names</title>
            <author fullname="IANA">
              <organization />
            </author>
            <date />
          </front>
        </reference>      </references>
      <references>
        <name>Informative References</name>

        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8499.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.9162.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8598.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.7686.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8806.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8106.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.4702.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.4704.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.6731.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.5986.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8310.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.7696.xml"/>
	<xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8792.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-add-dnr.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-ipsecme-add-ike.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-add-ddr.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-dnsop-domain-verification-techniques.xml"/>
    </references>
    </references>
  </back>
</rfc>
