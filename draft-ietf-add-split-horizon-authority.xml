<?xml version='1.0' encoding='utf-8'?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<?xml-model href="https://raw.githubusercontent.com/ietf-tools/xml2rfc/main/xml2rfc/data/v3.rng" schematypens="http://relaxng.org/ns/structure/1.0" type="application/xml"?>
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-ietf-add-split-horizon-authority-latest" ipr="trust200902" submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3" consensus="true">
  <front>
    <title abbrev="Establishing Local DNS Authority">Establishing Local DNS
    Authority in Validated Split-Horizon Environments</title>
    <seriesInfo name="Internet-Draft" value="draft-ietf-add-split-horizon-authority-latest"/>
    <author fullname="Tirumaleswar Reddy" initials="T." surname="Reddy">
      <organization>Nokia</organization>
      <address>
        <postal>
          <country>India</country>
        </postal>
        <email>kondtir@gmail.com</email>
      </address>
    </author>
    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Citrix">Citrix Systems, Inc.</organization>
      <address>
        <postal>
          <street>4988 Great America Pkwy</street>
          <city>Santa Clara</city>
          <region>CA</region>
          <code>95054</code>
          <country>USA</country>
        </postal>
        <email>danwing@gmail.com</email>
      </address>
    </author>
    <author fullname="Kevin Smith" initials="K." surname="Smith">
      <organization abbrev="Vodafone">Vodafone Group</organization>
      <address>
        <postal>
          <street>One Kingdom Street</street>
          <city>London</city>
          <country>UK</country>
        </postal>
        <email>kevin.smith@vodafone.com</email>
      </address>
    </author>
    <author fullname="Benjamin Schwartz" initials="B." surname="Schwartz">
      <organization abbrev="Meta">Meta Platforms, Inc.</organization>
      <address>
        <email>ietf@bemasc.net</email>
      </address>
    </author>
    <date/>
    <workgroup>ADD</workgroup>
    <abstract>
      <t>When split-horizon DNS is deployed by a network, certain domain names can
      be resolved authoritatively by a network-provided DNS resolver. DNS clients
      that are not configured to use this resolver by default can use it for
      these specific domains only. This specification defines a mechanism for domain owners
      to inform DNS clients about local resolvers that are authorized to answer
      authoritatively for certain subdomains.</t>
    </abstract>
    <note title="Discussion Venues" removeInRFC="true">
      <t>Discussion of this document takes place on the
          Adaptive DNS Discovery Working Group mailing list (add@ietf.org),
          which is archived at <eref target="https://mailarchive.ietf.org/arch/browse/add/"/>.</t>
      <t>Source for this draft and an issue tracker can be found at
          <eref target="https://github.com/ietf-wg-add/draft-ietf-add-split-horizon-authority"/>.</t>
      </note>
    </front>
  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>To resolve a DNS query, there are three main behaviors that an
      implementation can apply: (1) answer from a local database, (2) query
      the relevant authorities and their parents, or (3) ask a server to query
      those authorities and return the final answer. Implementations that use
      these behaviors are called "authoritative nameservers", "full/recursive
      resolvers", and "forwarders" (or "stub resolvers") respectively. However, an
      implementation can also implement a mixture of these behaviors,
      depending on a local policy, for each query. Such an implementation
      is termed a "hybrid resolver".</t>
      <t>Most DNS resolvers are hybrids of some kind. For example, stub
      resolvers support a local "hosts file" that preempts query
      forwarding, and most DNS forwarders and full resolvers can also serve
      responses from a local zone file. Other standardized hybrid resolution
      behaviors include <xref target="RFC8806">Local Root</xref>, <xref
      target="RFC6762">mDNS</xref>, and <xref target="RFC7686">NXDOMAIN
      synthesis for .onion</xref>.</t>
      <t>Networks usually offer clients a DNS resolver using means such as
      (e.g., DHCP OFFER, IPv6 Router Advertisement). Although this resolver is
      formally specified as a recursive resolver (e.g., <relref section="5.1"
      target="RFC8106"/>), some networks provide a hybrid resolver
      instead. If this resolver acts as an authoritative server for some names
      and provides different answers for those domains depending on the source
      of the query, it is described as the network having "split-horizon DNS", because those
      names resolve in this way only from inside the network.</t>
      <t>DNS clients that use pure stub resolution, sending all queries to
      the network-provided resolver, will always receive the split-horizon
      results. Conversely, clients that send all queries to a different
      resolver or implement pure full resolution locally will never receive
      them. Clients that strictly implement either of these resolution behaviors are out of scope for
      this specification. Instead, this specification enables hybrid clients
      to access split-horizon results from a network-provided hybrid resolver,
      while using a different resolution method for some or all other
      names.</t>
      <t>There are several existing mechanisms for a network to provide
      clients with "local domain hints", listing domain names that have
      special treatment in this network (e.g., <xref target="RFC6731">
      RDNSS Selection</xref>, <xref target="RFC5986">
      "Access Network Domain Name"</xref>, and "Client FQDN" <xref
      target="RFC4702"/><xref target="RFC4704"/> in DHCP, "dnsZones" in
      Provisioning Domains <xref target="RFC8801"/>, and <xref
      target="RFC8598">INTERNAL_DNS_DOMAIN</xref> in IKEv2).
      However, none of the local domain hint mechanisms enables clients to
      determine whether this special treatment is authorized by the domain
      owner. Instead, these specifications require clients to make their own
      determinations about whether to trust and rely on these hints.</t>
      <t>This document describes a mechanism between domain names, networks,
      and clients that allows the network to establish its authority over a
      domain to a client (<xref target="establishing"/>). Clients can
      use this protocol to confirm that a local domain hint was authorized by
      the domain owner (<xref target="validating"/>), which might influence
      its processing of that hint.  This process requires cooperation between
      the local DNS zone and the public zone.</t>
      <t>This specification relies on securely identified local DNS servers,
      and checks each local domain hint against a globally valid parent zone.</t>
    </section>
    <section anchor="notation">
      <name>Terminology</name>
      <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
      "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and
      "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"/><xref target="RFC8174"/> when, and
      only when, they appear in all capitals, as shown here.</t>
      <t>This document makes use of the terms defined in <xref
      target="RFC9499"/>, e.g., "Global DNS".  The following additional terms are
      used throughout the document:</t>
      <dl>
        <dt>Encrypted DNS</dt><dd>A DNS protocol that provides an
        encrypted channel between a DNS client and server (e.g., DNS
        over TLS (DoT) <xref
      target="RFC7858"/>, HTTPS (DoH) <xref
      target="RFC8484"/>, QUIC (DoQ) <xref
      target="RFC9250"/>).</dd>
        <dt>Encrypted DNS resolver</dt><dd>Refers to a DNS resolver
        that supports any encrypted DNS scheme.</dd>
          <dt>Split-Horizon DNS</dt><dd>The DNS service provided by a resolver
          that also acts as an authoritative server for some names, providing
          resolution results that are meaningfully different from those in the
          Global DNS. (See "Split DNS" in <relref section="6"
          target="RFC9499"/>.)</dd>
        <dt>Validated Split-Horizon</dt><dd>A split horizon configuration for
          some name is considered "validated" if the client has confirmed that
          a parent of that name has authorized this resolver  to serve its own
          responses for that name. Such authorization generally extends to the
          entire subtree of names below the authorization point.</dd>
      </dl>
      <t>In this document, the terms 'owner' and 'operator' are used interchangeably
      and refer to the individual or entity responsible for the management and
      maintenance of domains.</t>
    </section>
    <section>
      <name>Scope</name>
      <t>The protocol in this document is designed to support the ability of
      a domain owner to create or authorize a split-horizon view of their
      domain. The protocol does not support split-horizon views created by
      any other entity. Thus, DNS filtering is not enabled by this protocol.</t>
      <t>The protocol is applicable to any type of network offering
      split-horizon DNS configuration. The endpoint does not need any prior
      configuration to confirm that a local domain hint was indeed authorized
      by the domain.</t>
      <t>All of the special-use domain names registered with IANA <xref target="RFC6761"/>,
      most notably ".home.arpa", "resolver.arpa.", "ipv4only.arpa." and ".local", are never
      unique to a specific DNS server's authority. All special-use domain names are outside the
      scope of this document and MUST NOT be validated using the mechanism described in this document. </t>
      <t> Use of this specification is limited to DNS servers that support authenticated encryption and
      split-horizon DNS names that are rooted in the global DNS.</t>
    </section>
    <section>
      <name>Requirements</name>
      <t>This solution seeks to fulfill the following requirements:</t>
      <ul>
        <li>No loss of security: No unauthorized party can impersonate
          a zone unless they could already do so without use of this
          specification.</li>
        <li>Least privilege: Local resolvers do not hold any
          secrets that could weaken the security of the public zone if
          compromised.</li>
        <li>Local zone confidentiality: The specification does not leak
          local network subdomains to anyone outside of the network.</li>
        <li>Flexibility: The specification can represent and authorize
          a Split DNS zone structure.</li>
        <li>DNSSEC Compatibility: The specification supports DNSSEC-based
          <xref target="RFC9364"/> object security for local zone contents.</li>
      </ul>
    </section>
    <section anchor="establishing">
      <name>Establishing Local DNS Authority</name>
      <t>A participating network <bcp14>MUST</bcp14> offer one or more
      encrypted resolvers via DHCP and Router Advertisement Options for the
      Discovery of Network-designated Resolvers (DNR) <xref target="RFC9463"/>,
      Discovery of Designated Resolvers (DDR) <xref target="RFC9462"/>, or an
      equivalent mechanism (see <xref target="vpn"/>).</t>
      <t>To establish local authority, the network MUST convey one or more
      "Authorization Claims" to the client.  An "Authorization Claim" is an
      abstract structure comprising:</t>
      <ul>
        <li>An Authentication Domain Name (ADN) of a local encrypted resolver.</li>
        <li>The DNS name of the authorizing parent zone.</li>
        <li>A set of subdomains of this parent zone that are claimed by
            the named local resolver (potentially including the entire parent
            zone). To claim the entire parent zone, the claimed subdomain
            will be represented as an asterisk symbol "*".</li>
        <li>A ZONEMD Hash Algorithm (<relref section="5.3" target="RFC8976"/>).
           For interoperability purposes implementations MUST support the
           "mandatory to implement" hash algorithms defined in
           <relref section="2.2.3" target="RFC8976"/>. </li>
        <li>A high-entropy salt, up to 255 octets.</li>
      </ul>
      <t>If the local encrypted resolver is identified by name (e.g., DNR), that
      identifying name MUST be the one used in any corresponding Authorization
      Claim.  Otherwise (e.g., DDR using IP addresses), the resolver MUST
      present a validatable certificate containing a subjectAltName that
      matches the Authorization Claim using the validation techniques for
      matching as described in <xref target="RFC9525"/>.</t>
      <t>The network then provides each Authorization Claim to the parent zone operator.
      If the contents are approved, the parent zone operator computes a "Verification Token"
      according to the following procedure:</t>
      <ol>
        <li>Convert all subdomains into canonical form and sort them in canonical
            order (<relref section="6" target="RFC4034"/>).</li>
        <li>Replace the suffix corresponding to the parent zone with a zero
            octet.</li>
        <li>Let $X be the concatenation of the resulting pseudo-FQDNs.</li>
        <li>Let len($SALT) be the number of octets of salt, as a single octet.</li>
        <li>Let $TOKEN = hash(len($SALT) || $SALT || $X). Where "||" denotes concatenation and hash is the ZONEMD Hash Algorithm.</li>
      </ol>
      <t>The zone operator then publishes a "Verification Record" with the
      following structure, following advices such as in Sections 5.1 and 5.2 of
      <xref target="I-D.ietf-dnsop-domain-verification-techniques"/>:</t>
      <ul>
        <li>Type = TXT.</li>
        <li>Owner Name = Concatenation of the ADN, "_splitdns-challenge", and
            the parent zone name.</li>
        <li>Contents = "key/value" pairs, e.g., "token=base64url($TOKEN)" (without padding)</li>
      </ul>
      <t>By publishing this record, the parent zone authorizes the local
      encrypted resolver to serve these subdomains authoritatively.</t>
      <section>
        <name>Example</name>
        <t>Consider the following authorization claim:</t>
        <ul>
          <li>ADN = "resolver17.parent.example"</li>
          <li>Parent = "parent.example"</li>
          <li>Subdomains = "payroll.parent.example",
              "secret.project.parent.example"</li>
          <li>Hash Algorithm = SHA-384 <xref target="RFC6234"/></li>
          <li>Salt = "example salt octets (should be random)"</li>
        </ul>
        <t>To approve this claim, the zone operator would publish the following record:</t>
        <t>NOTE: '\' line wrapping per <xref target="RFC8792"/></t>
        <sourcecode type="dns-rr">
  resolver17.parent.example._splitdns-challenge.parent.example. \
  IN TXT "token=z1qyK7QWwQPkT-ZmVW-tAQbsNyYenTNBPp5ogYB8S1wesVCR\
  -KJDv2eFwfJcWQM"
</sourcecode>
      </section>
      <section>
        <name>Conveying Authorization Claims</name>
        <t>
          The Authorization Claim is an abstract structure that must be encoded in
          some concrete syntax in order to convey it from the network to the client.
          This section defines some encodings of the Authorization Claims.
        </t>
        <section>
          <name>Using DHCP</name>
          <t>
            In DHCP, each Authorization Claim is encoded as a DHCP Authentication
            Option (<xref target="RFC3118"/> and <relref section="21.11" target="RFC8415"/>),
            using the Protocol value $TBD1, "Split DNS Authentication". In DHCPv4 <xref target="RFC2131"/>, the long-options
            mechanism described in <relref section="8" target="RFC3396"/> MUST be used if the
            authentication option exceeds the maximum DHCPv4 option size of 255 octets. The Algorithm field
            provides the ZONEMD Hash Algorithm, represented by its registered Value.
            The Replay Detection Method value <bcp14>MUST</bcp14> be 0x00. The Authentication Information
            <bcp14>MUST</bcp14> contain the following information, concatenated:</t>
          <ol>
            <li>The ADN in canonical form.</li>
            <li>The parent name in canonical form.</li>
            <li>A one-octet "salt length" field.</li>
            <li>The salt value.</li>
            <li>The $X value defined in <xref target="establishing"/>.</li>
          </ol>
        </section>
        <section anchor="splitclaims">
          <name>Using Provisioning Domains</name>
          <t>When using <xref target="RFC8801">Provisioning Domains</xref>, the
          Authorization Claims are represented by the PvD Additional
          Information key "splitDnsClaims", whose value is a
          JSON Array.  Each entry in the array <bcp14>MUST</bcp14> be a JSON object
          with the following structure:</t>
          <ul>
            <li>"resolver": The ADN as a dot-separated name.</li>
            <li>"parent": The parent zone name as a dot-separated name.</li>
            <li>"subdomains": An array containing the claimed subdomains, as
                dot-separated names with the parent suffix already removed, in
                canonical order. To claim the entire parent zone, the claimed subdomain
                will be represented as an asterisk symbol "*".</li>
            <li>"algorithm": The hash algorithm is represented by its "Mnemonic"
                string from the ZONEMD Hash Algorithms registry (<relref target="RFC8976"
                section="5.2" displayFormat="comma"/>).</li>
            <li>"salt": The salt, encoded in base64url.</li>
          </ul>

        <t>Future specifications aiming to define new keys will need to add them to the
        IANA registry defined in <xref target="IANA"/>. DNS client implementations
        will ignore any keys they don't recognize but may also report about
        unknown keys.</t>
        </section>
      </section>
    </section>
    <section anchor="validating">
      <name>Validating Authority over Local Domain Hints</name>
      <t>To validate an Authorization Claim provided by the network, DNS clients
      <bcp14>MUST</bcp14> resolve the Verification Record for that name.
      If the resolution produces an RRSet containing the expected token for this
      Claim, the client <bcp14>SHALL</bcp14> regard the named resolver as
      authoritative for the claimed subdomains. Clients <bcp14>MUST</bcp14> ignore
      any unrecognized keys in the Verification Record.</t>
      <t>Each validation of authority applies only to a specific ADN.
      If a network offers multiple encrypted resolvers, each claimed
      subdomain may be authorized for a distinct subset of the network-provided
      resolvers.</t>
      <t>A zone is termed a "Validated Split-Horizon zone" after successful
      validation using a "tamperproof" DNS resolution method, i.e., a method
      that is not subject to interference by the local network operator. Two
      possible tamperproof resolution methods are presented below.</t>
      <section anchor="validating-external">
        <name>Using a Pre-configured External Resolver</name>
        <t>This method applies only if the client is already configured with
        a default resolution strategy that sends queries to a resolver outside
        of the network over a encrypted transport.  That resolution strategy is
        considered "tamperproof" because any actor who could modify the
        response could already modify all of the user's other DNS responses.</t>
        <t>To ensure that this assumption holds, clients <bcp14>MUST NOT</bcp14>
        relax the acceptance rules they would otherwise apply when using this
        resolver. For example, if the client would check the Authenticated Data (AD)
        bit or validate RRSIGs locally when using this resolver, it must also do so
        when resolving TXT records for this purpose. Alternatively, a client might
        perform DNSSEC validation for the verification query
        even if it has disabled DNSSEC validation for other DNS queries.</t>
      </section>
      <!-- validating-external -->

      <section anchor="validating-dnssec">
        <name>Using DNSSEC</name>
        <t>The client resolves the Verification Record using any resolution method of
        its choice (e.g., querying one of the network-provided resolvers,
        performing iterative resolution locally), and performs full DNSSEC
        validation locally <xref target="RFC6698"/>. The result is
        processed based on its DNSSEC validation state (<relref section="4.3"
        target="RFC4035" displayFormat="comma"/>): </t>
        <ul empty="true">
          <li><strong>Secure</strong>: The response is used for validation.</li>
          <li><strong>Bogus</strong> or <strong>Indeterminate</strong>: The response is rejected and
            validation is considered to have failed.</li>
          <li><strong>Insecure</strong>: The client <bcp14>SHOULD</bcp14> retry the validation
            process using a different method, such as the one in <xref
            target="validating-external"/>, to ensure compatibility with
            unsigned names.</li>
        </ul>
      </section>
      <!-- validating-DNSSEC -->
    </section>
    <!-- Validating -->

    <section>
      <name>Delegating DNSSEC across Split DNS Boundaries</name>
      <t>When the local zone can be signed with globally trusted keys for the parent
      zone, support for DNSSEC can be accomplished simply by placing a zone cut at
      the parent zone and including a suitable DS record for the local resolver's
      DNSKEY.  Zones in this configuration appear the same to validating stubs whether
      or not they implement this specification.</t>
      <t>To enable DNSSEC validation of local DNS names without requiring
      the local resolver to hold DNSSEC private keys that are valid for the parent
      zone, parent zones <bcp14>MAY</bcp14> add a "ds=..." key to the Verification
      Record whose value is the RDATA of a single DS record, base64url-encoded. This
      DS record authorizes a DNSKEY whose Owner Name is "resolver.arpa."</t>
      <t>To validate DNSSEC, the client first fetches and validates the Verification
      Record.  If it is valid and contains a "ds" key, the client <bcp14>MAY</bcp14>
      send a DNSKEY query for "resolver.arpa." to the local encrypted resolver.
      At least one resulting DNSKEY RR <bcp14>MUST</bcp14> match the DS RDATA from
      the "ds" key in the Verification Record. All local resolution results for
      subdomains in this claim <bcp14>MUST</bcp14> offer RRSIGs that chain to a
      DNSKEY whose RDATA is identical to one of these approved DNSKEYs.</t>
      <t>The "ds" key <bcp14>MAY</bcp14> appear multiple
      times in a single Verification Record, in order to authorize multiple DNSKEYs
      for this local encrypted resolver.  If the "ds" key is not present in a valid
      Verification Record, the client <bcp14>MUST</bcp14> disable DNSSEC validation
      when resolving the claimed subdomains via this local encrypted resolver.</t>
      <t>Note that in this configuration, any claimed subdomains MUST be marked as
      unsigned in the public DNS.  Otherwise, resolution results would be rejected
      by validating stubs that do not implement this specification.</t>
      <figure>
        <name>Example use of "ds=..."</name>
        <sourcecode>
;; Parent zone.
$ORIGIN parent.example.

; Parent zone's public KSK and ZSK
@ IN DNSKEY 257 3 5 ABCD...=
@ IN DNSKEY 256 3 5 DCBA...=

; Verification Record containing DS RDATA for the local
; resolver's KSK.  This is an ordinary public TXT record,
; secured by RRSIGs from the public ZSK.
resolver.example._splitdns-challenge IN TXT "token=abc...,ds=QWE..."

; NSEC record indicating that unsigned delegations are permitted at
; this subdomain.  This is required for compatibility with non-split-aware
; validating stub resolvers.  If the claimed label is confidential, the
; parent zone can conceal it using NSEC3 (with or without "opt-out").
@ IN NSEC subdomain.parent.example. NS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Local zone, claiming "subdomain.parent.example".

; The local resolver's KSK, validated by the Verification Record.
; It may not have a corresponding RRSIG.
resolver.arpa. IN DNSKEY 257 3 5 ASDF...=

; Each claimed subdomain duplicates the local resolver's KSK at its
; zone apex and uses it to sign the ZSK.
subdomain.parent.example.        IN DNSKEY 257 3 5 ASDF...=
subdomain.parent.example.        IN DNSKEY 256 3 5 FDSA...=
subdomain.parent.example         IN RRSIG DNSKEY 5 3 ...  \
        (KSK key tag) subdomain.parent.example. ...
subdomain.parent.example.        IN AAAA 2001:db8::17
subdomain.parent.example         IN RRSIG AAAA 5 3 ...    \
        (ZSK key tag) subdomain.parent.example. ...
deeper.subdomain.parent.example. IN AAAA 2001:db8::18
deeper.subdomain.parent.example  IN RRSIG AAAA 5 3 ...    \
        (ZSK key tag) subdomain.parent.example. ...
</sourcecode></figure>
    </section>

    <section>
      <name>Examples of Split-Horizon DNS Configuration</name>
      <t>Two examples are shown below. The first example shows a company
      with an internal-only DNS server that claims the entire zone for that
      company (e.g., <tt>*.example.com</tt>). In the second example, the
      internal servers resolves only a
      subdomain of the company's zone (e.g., <tt>*.internal.example.com</tt>).</t>
      <section anchor="internal-only">
        <name>Split-Horizon Entire Zone</name>
        <t>Consider an organization that operates "example.com", and runs a
        different version of its global domain on its internal network.</t>
        <t>First, the host and network both need to support one of the discovery
        mechanisms described in <xref target="establishing"/>. <xref target="fig-learn"/>
        shows discovery using DNR and PvD.</t>
        <t>Validation is then perfomed using either <xref
        target="example-verify-external">an external resolver</xref> or <xref
        target="example-verify-dnssec">DNSSEC</xref>.</t>
        <ul empty="true">
          <li><strong>Steps 1-2</strong>: The client determines the network's DNS
            server (dns.example.net) and Provisioning Domain (pvd.example.com)
            using <xref target="RFC9463">DNR</xref> and <xref
            target="RFC8801">PvD</xref>, using one of DNR Router Solicitation,
            DHCPv4, or DHCPv6.</li>
          <li><strong>Step 3-5</strong>: The client connects to dns.example.net
            using an encrypted transport as indicated in <xref
            target="RFC9463">DNR</xref>, authenticating the server to
            its name using TLS (<relref target="RFC8310" section="8"
            displayFormat="comma"/>), and
            sends it a query for the address of <tt>pvd.example.com</tt>.</li>
          <li><t><strong>Steps 6-7</strong>: The client connects to the PvD server,
            validates its certificate, and retrieves the provisioning domain
            JSON information indicated by the associated PvD. The PvD
            contains:</t>
            <sourcecode type="json">{
  "identifier": "pvd.example.com",
  "expires": "2025-05-23T06:00:00Z",
  "prefixes": ["2001:db8:1::/48", "2001:db8:4::/48"],
  "splitDnsClaims": [{
    "resolver": "dns.example.net",
    "parent": "example.com",
    "subdomains": ["*"],
    "algorithm": "SHA384",
    "salt": "abc...123"
  }]
}</sourcecode>
            <t>The JSON keys "identifier", "expires", and "prefixes"
            are defined in <xref target="RFC8801"/>.</t></li>
        </ul>
        <figure anchor="fig-learn">
          <name>An Example of Learning Local Claims of DNS Authority</name>
          <artwork><![CDATA[
+---------+         +--------------------+  +------------+ +--------+
| Client  |         | Network's          |  | Network    | | Router |
|         |         | Encrypted Resolver |  | PvD Server | |        |
+---------+         +--------------------+  +------------+ +--------+
   |                                     |         |            |
   | Router Solicitation or              |         |            |
   | DHCPv4/DHCPv6 (1)                   |         |            |
   |----------------------------------------------------------->|
   |                                     |         |            |
   |  Response with DNR ADN &            |         |            |
   |  PvD FQDN (2)                       |         |            |
   |<-----------------------------------------------------------|
   | ----------------------------\       |         |            |
   |-| now knows DNR ADN &       |       |         |            |
   | | PvD FQDN                  |       |         |            |
   | |---------------------------/       |         |            |
   |                                     |         |            |
   | TLS connection to dns.example.net (3)         |            |
   |------------------------------------>|         |            |
   | ---------------------------\        |         |            |
   |-| validate TLS certificate |        |         |            |
   | |--------------------------/        |         |            |
   |                                     |         |            |
   | resolve pvd.example.com  (4)        |         |            |
   |------------------------------------>|         |            |
   |                                     |         |            |
   |            A or AAAA records (5)    |         |            |
   |<------------------------------------|         |            |
   |                                     |         |            |
   | https://pvd.example.com/.well-known/pvd (6)   |            |
   |---------------------------------------------->|            |
   |                                     |         |            |
   |  200 OK (JSON Additional Information) (7)     |            |
   |<----------------------------------------------|            |
   | ----------------------------------\ |         |            |
   |-| {..., "splitDnsClaims": [...] } | |         |            |
   | |---------------------------------/ |         |            |
]]></artwork>
        </figure>
        <section anchor="example-verify-external">
          <name>Verification Using an External Resolver</name>
          <t><xref target="fig-learn2"/> shows the steps performed to verify the local
          claims of DNS authority using an external resolver.</t>
          <ul empty="true">
            <li><strong>Steps 1-2</strong>: The client uses an encrypted DNS
              connection to an external resolver to issue TXT
              queries for the Verification Records. The TXT lookup returns
              a token that matches the claim.</li>
            <li><strong>Step 3</strong>: The client has validated that
              <tt>example.com</tt> has authorized <tt>dns.example.net</tt>
              to serve <tt>example.com</tt>. When the client connects using an
              encrypted transport as indicated in <xref
              target="RFC9463">DNR</xref>, it will authenticate
              the server to its name using TLS (<relref target="RFC8310"
              section="8" displayFormat="comma"/>), and send queries to resolve
              any names that fall within the claimed zones.</li>
          </ul>
          <figure anchor="fig-learn2">
            <name>Verifying claims using an external resolver</name>
            <artwork><![CDATA[
+---------+                  +--------------------+  +----------+
| Client  |                  | Network's          |  | External |
|         |                  | Encrypted Resolver |  | Resolver |
+---------+                  +--------------------+  +----------+
     |                                          |         |
     | TLS connection                           |         |
     |--------------------------------------------------->|
     | ---------------------------\             |         |
     |-| validate TLS certificate |             |         |
     | |--------------------------|             |         |
     |                                          |         |
     | TXT? dns.example.net.\                   |         |
     |   _splitdns-challenge.example.com  (1)   |         |
     |--------------------------------------------------->|
     |                                          |         |
     |  TXT "token=ABC..."                  (2) |         |
     |<---------------------------------------------------|
     | --------------------------------\        |         |
     |-| dns.example.net is authorized |        |         |
     | ----------------------\---------|        |         |
     |-| finished validation |                  |         |
     | |---------------------|                  |         |
     |                                          |         |
     |  use dns.example.net when                |         |
     |  resolving example.com (3)               |         |
     |----------------------------------------->|         |
     |                                          |         |
]]></artwork>
          </figure>
        </section>
        <!-- external -->

        <section anchor="example-verify-dnssec">
          <name>Verification using DNSSEC</name>
          <t><xref target="fig-learn3"/> shows the steps performed to verify the local
          claims of DNS authority using DNSSEC.</t>
          <ul empty="true">
            <li><strong>Steps 1-2</strong>: The DNSSEC-validating client queries
              the network encrypted resolver to issue TXT queries for the
              Verification Records. The TXT lookup will return
              a signed response containing the expected token. The client then
              performs full DNSSEC validation locally.</li>
            <li><strong>Step 3</strong>: If the DNSSEC validation is successful and
              the token matches, then this Authorization Claim is validated.
              Once the client connects using an encrypted transport as indicated
              in <xref target="RFC9463">DNR</xref>, it will authenticate
              the server to its name using TLS (<relref target="RFC8310"
              section="8" displayFormat="comma"/>), and send queries to resolve
              any names that fall within the claimed zones.</li>
          </ul>
          <figure anchor="fig-learn3">
            <name>An Example of Verifying Claims using DNSSEC</name>
            <artwork><![CDATA[
+---------+                                    +--------------------+
| Client  |                                    | Network's          |
|         |                                    | Encrypted Resolver |
+---------+                                    +--------------------+
  |                                                               |
  | DNSSEC OK (DO), TXT? dns.example.net.\                        |
  |   _splitdns-challenge.example.com  (1)                        |
  |-------------------------------------------------------------->|
  |                                                               |
  | TXT token=DEF..., Signed Answer (RRSIG) (2)                   |
  |<--------------------------------------------------------------|
  | -------------------------------------\                        |
  |-| DNSKEY+TXT matches RRSIG, use TXT  |                        |
  | |------------------------------------|                        |
  | --------------------------------\                             |
  |-| dns.example.net is authorized |                             |
  | |-------------------------------|                             |
  | ----------------------\                                       |
  |-| finished validation |                                       |
  | |---------------------|                                       |
  |                                                               |
  | use encrypted network-designated resolver for example.com (3) |
  |-------------------------------------------------------------->|
  |                                                               |
]]></artwork>
          </figure>
        </section>
      </section>
    </section>
    <section anchor="operatonal">
      <name>Operational Efficiency in Split-Horizon Deployments</name>
        <t>In many split-horizon deployments, all non-public domain names are
        placed in a separate child zone (e.g., <tt>internal.example.com</tt>).
        In this configuration, the message flow is similar to <xref
        target="internal-only"/>, except that queries for hosts not within the
        subdomain (e.g., <tt>www.example.com</tt>) are sent to the
        external resolver rather than the resolver for internal.example.com.</t>
        <t>As in <xref target="internal-only"/>, the internal DNS
        server will need a certificate signed by a Certification Authority (CA) trusted by the
        client.</t>
        <t>Although placing internal domains inside a child domain is unnecessary to prevent leakage,
        such placement reduces the frequency of changes to the Verification Record, this document
        recommends the internal domains be kept in a child zone of the local domain hints
        advertised by the network. For example, if the PvD "dnsZones" entry is
        "internal.example.com" and the network-provided DNS resolver is "ns1.internal.example.com",
        the network operator can structure the internal domain names as
        "private1.internal.example.com", "private2.internal.example.com",
        etc. The network-designated resolver will be used to resolve the subdomains of
        the local domain hint "*.internal.example.com".</t>
    </section>
    <section anchor="vpn">
      <name>Validation with IKEv2</name>
      <t>When the VPN tunnel is IPsec, the encrypted DNS resolver hosted by
      the VPN service provider can be securely discovered by the endpoint
      using the ENCDNS_IP*_* IKEv2 Configuration Payload Attribute Types
      defined in <xref target="RFC9464"/>. The VPN client
      can use the mechanism defined in Section 6 to validate that the discovered
      encrypted DNS resolver is authorized to answer for the claimed subdomains.</t>
      <t>Other VPN tunnel types have similar configuration capabilities, not
      detailed here.</t>
    </section>
    <section anchor="aclaim">
      <name>Authorization Claim Update</name>
      <t>A verification record is only valid until it expires. Expiry occurs when the Time To Live (TTL)
      or DNSSEC signature validity period ends. Shortly before verification record expiry, clients MUST
      fetch the verification records again and repeat the verification procedure. This ensures the
      availability of updated and valid verification records.</t>
      <t>A new verification record must be added to the RRset before the corresponding Authorization
      Claim is updated.  After the claim is updated, the following procedures can be used:</t>
      <ol>
        <li>DHCP reconfiguration can be initiated by a DHCP server that has previously communicated with a DHCP client and
   negotiated for the DHCP client to listen for Reconfigure messages, to prompt the DHCP clients for
        dynamically requesting the updated Authorization Claim. This process avoids the need for
        the client to wait for its current lease to complete and request a new one, enabling the lease
        renewal to be driven by the DHCP server.</li>
        <li>The sequence number in the RA PvD option
        will be incremented, requiring clients to fetch PvD additional information from the HTTPS
        server due to the updated sequence number in the new RA (<relref target="RFC8801" section="4.1"
        displayFormat="comma"/>).</li>
        <li>The old verification record needs to be maintained until the DHCP lease time or PvD
        Additional Information expiry.</li>
      </ol>
    </section>
    <section anchor="Security">
      <name>Security Considerations</name>
      <t>The Authentication Domain Names of authorized local encrypted resolvers are
      revealed in the Owner Names of Verification Records.  This makes it easier for
      domain owners to understand which resolvers they are currently authorizing to
      implement Split DNS. However, this could create a confidentiality issue if the
      local encrypted resolver's name contains sensitive information or is part of a
      secret subdomain. To mitigate the impact of such leakage, local resolvers should
      be given names that do not reveal any sensitive information.</t>
      <t> The security properties of hashing algorithms are not fixed. Algorithm Agility
      (see <xref target="RFC7696"/>) is achieved by providing implementations with
      flexibility to choose hashing algorithms from the ZONEMD Schemes registry
      (<relref target="RFC8976" section="5.2" displayFormat="comma"/>).</t>
      <t>The entropy of salt depends on a high-quality pseudo-random number generator.
      For further discussion on random number generation, see <xref target="RFC4086"/>.
      The salt MUST be regenerated whenever the authorization claim is updated.</t>
    </section>
    <section anchor="IANA">
      <name>IANA Considerations</name>
      <section>
        <name>DHCP Split DNS Authentication Algorithm</name>
        <t>IANA is requested to add the following entry to the "Protocol Name Space
        Values" registry on the "Dynamic Host Configuration Protocol (DHCP)
        Authentication Option Name Spaces" page:</t>
        <ul>
          <li>Value: $TBD1</li>
          <li>Description: Split-horizon DNS</li>
          <li>Reference: (This Document)</li>
        </ul>
      </section>
      <section>
        <name>Provisioning Domains Split DNS Additional Information</name>
        <t>IANA is requested to add the following entry to the "Additional
        Information PvD Keys" registry under the "Provisioning Domains (PvDs)" registry group:</t>
        <ul>
          <li>JSON key: "splitDnsClaims"</li>
          <li>Description: "Verifiable locally served domains"</li>
          <li>Type: Array of Objects</li>
          <li><t>Example: </t><sourcecode type="json">[{
  "resolver": "dns.example.net",
  "parent": "example.com",
  "subdomains": ["sub"],
  "algorithm": "SHA384",
  "salt": "abc...123"
}]</sourcecode></li>
          <li>Reference: (This document)</li>
        </ul>
      </section>
      <section>
        <name>New PvD Split DNS Claims Registry</name>
        <t>IANA is requested to create a new registry "PvD Split DNS Claims" Registry,
        within the "Provisioning Domains (PvDs)" registry page.  This new registry
        reserves JSON keys for use in sub-dictionaries under the splitDnsClaims JSON key.
        The initial contents of this registry, as discussed in <xref target="splitclaims"/>,
        are listed below and will be added to the IANA registry:</t>
        <figure anchor="fig-split-claims">
          <name>Split DNS Claims</name>
          <artwork><![CDATA[
+------------+-----------------------+---------+-----------------+-----------+
| JSON key   | Description           | Type    | Example         | Reference |
+------------+-----------------------+---------+-----------------+-----------+
| resolver   | The Authentication    | String  |"dns.example.net"| [RFCXXXX] |
|            | Domain Name           |         |                 |           |
|            |                       |         |                 |           |
| parent     | The parent zone name  | String  | "example.com"   | [RFCXXXX] |
|            |                       |         |                 |           |
| subdomains | An array containing   | Array of| ["sub"]         |           |
|            | the claimed subdomains| Strings |                 | [RFCXXXX] |
|            |                       |         |                 |           |
| algorithm  | The hash algorithm    | String  | "SHA384"        | [RFCXXXX] |
|            |                       |         |                 |           |
| salt       | The salt (base64url)  | String  | "abc...123"     | [RFCXXXX] |
|            |                       |         |                 |           |
+------------+-----------------------+---------+-----------------+-----------+
]]></artwork>
        </figure>
        <t>The keys defined in this document are mandatory. Any new assignments of keys will be considered
        as optional for the purpose of the mechanism described in this document.</t>
        <t>New assignments in the "PvD Split DNS Claims Registry" registry will be
        administered by IANA through Expert Review <xref target="RFC8126"/>. Experts are
        requested to ensure that defined keys do not overlap in names or semantics.</t>
        <section>
          <name>Guidelines for the Designated Experts</name>
          <t>It is suggested that multiple designated experts be appointed for
          registry change requests.</t>

          <t>Criteria that should be applied by the designated experts include
          determining whether the proposed registration duplicates existing
          entries and whether the registration description is clear and fits
          the purpose of this registry.</t>

          <t>Registration requests are evaluated within a three-week review period
          on the advice of one or more designated experts. Within the review
          period, the designated experts will either approve or deny the
          registration request, communicating this decision to IANA. Denials
          should include an explanation and, if applicable, suggestions as to
          how to make the request successful.</t>

        </section>
      </section>
      <section>
        <name>DNS Underscore Name</name>
        <t>IANA is requested to add the following entry to the "Underscored and
        Globally Scoped DNS Node Names" registry under the "Domain Name System (DNS)
        Parameters" registry group:</t>
        <ul>
          <li>RR Type: TXT</li>
          <li>_NODE NAME: _splitdns-challenge</li>
          <li>Reference: (This document)</li>
        </ul>
      </section>
    </section>
    <section>
      <name>Acknowledgements</name>
      <t>Thanks to Mohamed Boucadair, Jim Reid, Tommy Pauly, Paul Vixie, Michael Richardson,
      Bernie Volz, Éric Vyncke and Vinny Parla for the discussion and comments.</t>

      <t>Thanks to Tianran Zhou for the opsdir review, Anthony Somerset for the dnsdir review,
      Watson Ladd for the secdir review, Bob Halley for the intdir review and Mallory Knodel
      for the genart review.</t>

      <t>Thanks to Mohamed Boucadair for the Shepherd review.</t>

    </section>
  </middle>
  <!--  *****BACK MATTER ***** -->

  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.3118.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.2131.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.4034.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8801.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.6698.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.4035.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8976.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8415.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.3396.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.6761.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.9525.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.4086.xml"/>
      </references>
      <references>
        <name>Informative References</name>

        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.9499.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8598.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.7686.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8806.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8106.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.4702.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.4704.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.6731.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.5986.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8310.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.7696.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.7858.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8484.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.9250.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.9364.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.6234.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.6762.xml"/>
	<xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.8792.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.9463.xml"/>
        <xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.9464.xml"/>
	<xi:include href="https://www.rfc-editor.org/refs/bibxml/reference.RFC.9462.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-dnsop-domain-verification-techniques.xml"/>
    </references>
    </references>
  </back>
</rfc>
